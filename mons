#!/bin/sh
#
# The MIT License (MIT)
#
# Copyright (c) 2015-2016 Thomas "Ventto" Venri√®s <thomas.venries@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
if [ ! -f "/usr/lib/posix-shell-list/list.sh" ]; then
    echo '/usr/lib/posix-shell-list/list.sh: library not found.'
    exit 1
fi

. /usr/lib/posix-shell-list/list.sh

usage() {
    echo 'Usage: mons [OPTION]...

Options can not be used in conjunction.
If no argument, prints plugged-in monitor list with their ids.

Information:
  -h    Prints this help and exits.
  -v    Prints version and exits.

Two monitors:
  -o    Primary monitor only.
  -s    Second monitor only.
  -d    Duplicates the primary monitor.
  -m    Mirrors the primary monitor.
  -e <side>
         Extends the primary monitor to the selected side
         [ top | left | right | bottom ].
  -n <side>
         This mode selects the previous ones, one after another. The argument
         sets the side for the extend mode.

More monitors:
  -O <mon>
        Only enables the selected monitor wuth an id.
  -S <mon1>,<mon2>:<pos>
        Only enables two selected monitors with ids (<mon1>, <mon2>),
        <pos> places the second one to the right or at top [R | T].

Extra:
  --dpi <dpi>
        Set the DPI, a strictly positive value within the range [0 ; 27432].

Daemon mode:
  -a    Performs an automatic display if it detects only one monitor.
'
}

version() {
    echo 'Mons 0.7
Copyright (C) 2016 Thomas "Ventto" Venries.

License MIT: <https://opensource.org/licenses/MIT>.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
'
}

arg_err() {
    usage ; exit 2
}

enable_mon() {
    "${XRANDR}" --output "${1}" --auto --dpi "${dpi}"
}

disable_mons() {
    for mon in $@; do "${XRANDR}" --output "${mon}" --off ; done
}

arg2xrandr() {
    case $1 in
        left)   echo '--left-of'    ;;
        right)  echo '--right-of'   ;;
        bottom) echo '--below'      ;;
        top)    echo '--above'      ;;
    esac
}

whichmode() {
    if [ "$(list_len "${disp_mons}")" -eq 1 ]; then
        if echo "${enabled_out}" | grep prima > /dev/null 2>&1; then
            echo 'primary'
        else
            echo 'second'
        fi
    else
        if [ "$(list_len "${plug_mons}")" -gt 2 ] ; then
            echo 'selection'; return 0
        fi

        enabled_out="$(echo "${enabled_out}" | \
                        sed 's/^.*\( [0-9]\+\x[0-9]\++[0-9]\++[0-9]\+\).*/\1/')"

        echo "${enabled_out}" | head -n1 | sed -e 's/+/ /g' | \
        while read -r trash x1 y1; do
            echo "${enabled_out}" | tail -n1 | sed -e 's/x/ /' -e 's/+/ /g' | \
            while read -r w2 h2 x2 y2; do
                echo "${xrandr_out}" | \
                    awk "/^$(list_get 1 "${plug_mons}")/{nr[NR+1]}; NR in nr" | \
                    awk '{print $1;}' | sed -e 's/x/ /' | \
                while read -r wi2 hi2; do
                    if [ "$x1" = "$x2" ] && [ "$y1" = "$y2" ]; then
                        if [ "$w2" != "$wi2" ] || [ "$h2" != "$hi2" ]; then
                            echo 'mirror'
                        else
                            echo 'duplicate'
                        fi
                    else
                        echo 'extend'
                    fi
                done
            done
        done
    fi
}

main() {
    aFlag=false
    dFlag=false
    eFlag=false
    mFlag=false
    nFlag=false
    oFlag=false
    sFlag=false
    OFlag=false
    SFlag=false
    is_flag=false

    # As X has typically assumed 96 DPI and this is fine for many traditional
    # monitors.
    dpi=96

    # getopts does not support long options. Pre-parsing is required.
    for opt in "$@"; do
        shift
        if [ "$opt" = '--dpi' ]; then
            ! echo "$1" | grep -E '^[1-9][0-9]*$' > /dev/null && arg_err
            # xrandr lets user set the DPI value within the range [0;27432]
            [ "$1" -eq 0 -o "$1" -gt 27432 ] && arg_err
            dpi="$1"
            is_flag=true; continue
        fi
        $is_flag && { is_flag=false; continue; }
        set -- "$@" "$opt"
    done

    while getopts 'hvamosde:n:O:S:' opt; do
        case $opt in
            h)  usage   ; exit ;;
            v)  version ; exit ;;
            a)  $is_flag && arg_err
                aFlag=true ; is_flag=true
                ;;
            m)  $is_flag && arg_err
                mFlag=true ; is_flag=true
                ;;
            o)  $is_flag && arg_err
                oFlag=true ; is_flag=true
                ;;
            s)  $is_flag && arg_err
                sFlag=true ; is_flag=true
                ;;
            d)  $is_flag && arg_err
                dFlag=true ; is_flag=true
                ;;
            e|n)  $is_flag && arg_err
                case ${OPTARG} in
                    left | right | bottom | top) ;;
                    *) arg_err ;;
                esac
                eArg=$OPTARG
                [ "$opt" = "e" ] && eFlag=true || nFlag=true ; is_flag=true
                ;;
            O)  $is_flag && arg_err
                ! echo "${OPTARG}" | grep -E '^[0-9]+$' > /dev/null && arg_err
                OArg=$OPTARG
                OFlag=true ; is_flag=true
                ;;
            S)  $is_flag && arg_err
                idx1="$(echo "${OPTARG}" | cut -d',' -f1)"
                idx2="$(echo "${OPTARG}" | cut -d',' -f2)"
                area="$(echo "${idx2}" | cut -d ':' -f2)"
                idx2="$(echo "${idx2}" | cut -d ':' -f1)"
                ! echo "${idx1}" | grep -E '^[0-9]+$' > /dev/null && arg_err
                ! echo "${idx2}" | grep -E '^[0-9]+$' > /dev/null && arg_err
                ! echo "${area}" | grep -E '^[RT]$' > /dev/null && arg_err
                [ "${idx1}" = "${idx2}" ] && arg_err
                SFlag=true ; is_flag=true
                ;;
            \?) arg_err ;;
            :)  arg_err ;;
        esac
    done

    XRANDR="$(command -v xrandr)"
    if [ "$?" -ne 0 ]; then
        echo 'xrandr: command not found.' ; exit 1
    fi

    [ -z "${DISPLAY}" ] && { echo 'X: server not started.'     ; exit 1; }
    [ -z "${XRANDR}" ]  && { echo 'xrandr: command not found.' ; exit 1; }

    if $aFlag ; then
        previous=0; current=0
        while true; do
            current="$("${XRANDR}" | grep -c ' connect')"
            if [ "$current" -eq 1 ] && [ "$current" -ne "$previous" ]; then
                "${XRANDR}" --auto --dpi "${dpi}"
            fi
            sleep 3
            previous="$current"
        done
    fi

    # From xrandr basic output, we build monitor lists
    xrandr_out="$("${XRANDR}")"
    enabled_out="$(echo "${xrandr_out}" | grep connect)"
    [ -z "${enabled_out}" ] && { echo 'No monitor output detected.'; exit; }
    mons="$(echo "${enabled_out}" | cut -d' ' -f1)"
    enabled_out="$(echo "${enabled_out}" | grep ' connect')"
    [ -z "${enabled_out}" ] && { echo 'No plugged-in monitor detected.'; exit 1; }
    plug_mons="$(echo "${enabled_out}" | cut -d' ' -f1)"
    enabled_out="$(echo "${enabled_out}" | grep -E '\+[0-9]{1,4}\+[0-9]{1,4}')"
    disp_mons="$(echo "${enabled_out}" | cut -d' ' -f1)"

    if [ "$#" -eq 0 ]; then
        echo "Monitors: $(list_len "${plug_mons}")"
        echo "Mode: $(whichmode)"

        i=0
        for mon in ${mons}; do
            if echo "${plug_mons}" | grep "^${mon}$" > /dev/null; then
                if echo "${disp_mons}" | grep "^${mon}$" > /dev/null; then
                    state='(enabled)'
                fi
                printf '%-3s %-9s %-9s\n' "${i}:" "${mon}" "${state}"
            fi
            i=$((i+1))
            state=
        done
        exit
    fi

    if $nFlag ; then
        case "$(whichmode)" in
            primary)   sFlag=true;;
            second)    eFlag=true;;
            extend)    mFlag=true;;
            mirror)    dFlag=true;;
            duplicate) oFlag=true;;
        esac
    fi

    if [ "$(list_len "${plug_mons}")" -eq 1 ] ; then
        if $oFlag ; then
            # After unplugging each monitor, the last preferred one might be
            # still turned off or the window manager might need the monitor
            # reset to cause the reconfiguration of the layout placement.
            "${XRANDR}" --auto --dpi "${dpi}"
        else
            echo 'Only one monitor detected.'
        fi
        exit
    fi

    if $oFlag ; then
        if [ "$(list_len "${disp_mons}")" -eq 1 ]; then
            if [ "$(list_head "${disp_mons}")" = "$(list_head "${plug_mons}")" ]; then
                exit
            fi
        fi
        disp_mons="$(list_del "$(list_head "${plug_mons}")" "$disp_mons")"
        disable_mons "${disp_mons}"
        enable_mon "$(list_head "${plug_mons}")"
        exit
    fi

    if $OFlag ; then
        if [ "${OArg}" -ge "$(list_len "${mons}")" ] ; then
            echo "Monitor ID '${OArg}' does not exist."
            echo 'Try without option to get monitor ID list.'
            exit 2
        fi
        mons_elt="$(list_get "${OArg}" "${mons}")"
        if ! list_contains "${mons_elt}" "${plug_mons}"; then
            echo "Monitor ID '${OArg}' not plugged in."
            echo 'Try without option to get monitor ID list.'
            exit 2
        fi

        disp_mons="$(list_del "${mons_elt}" "${disp_mons}")"
        disable_mons "${disp_mons}"
        enable_mon "${mons_elt}"
        exit
    fi

    if $SFlag ; then
        if [ "${idx1}" -ge "$(list_len "${mons}")" ] || \
            [ "${idx2}" -ge "$(list_len "${mons}")" ]; then
            echo 'One or both monitor IDs do not exist.'
            echo 'Try without option to get monitor ID list.'
            exit 2
        fi
        if ! list_contains "$(list_get "${idx1}" "${mons}")" "${plug_mons}" || \
            ! list_contains "$(list_get "${idx2}" "${mons}")" "${plug_mons}" ; then
            echo 'One or both monitor IDs are not plugged in.'
            echo 'Try without option to get monitor ID list.'
            exit 2
        fi

        [ "${area}" = 'R' ] && area="--right-of" || area="--above"

        mon1="$(list_get "${idx1}" "${mons}")"
        mon2="$(list_get "${idx2}" "${mons}")"
        disp_mons="$(list_del "${mon1}" "${disp_mons}")"
        disp_mons="$(list_del "${mon2}" "${disp_mons}")"
        disable_mons "${disp_mons}"
        enable_mon "${mon1}"
        enable_mon "${mon2}"
        "${XRANDR}" --output "${mon2}" "${area}" "${mon1}"
        exit
    fi

    if [ "$(list_len "${plug_mons}")" -eq 2 ]; then
        if $sFlag ; then
            if [ "$(list_len "${disp_mons}")" -eq 1 ] ; then
                if [ "$(list_head "${disp_mons}")" = "$(list_get 1 "${plug_mons}")" ] ; then
                    enable_mon "$(list_get 1 "${plug_mons}")"
                    exit
                fi
            fi
            enable_mon "$(list_get 1 "${plug_mons}")"
            disable_mons "$(list_head "${disp_mons}")"
            exit
        fi

        # Resets the screen configuration
        disable_mons "$(list_get 1 "${plug_mons}")"
        "${XRANDR}" --auto --dpi "${dpi}"

        if $dFlag ; then
            "${XRANDR}" --output "$(list_get 1 "${plug_mons}")" \
                --same-as "$(list_head "${plug_mons}")"
            exit $?
        fi

        if $mFlag ; then
            xrandr_out="$(echo "${xrandr_out}" | \
                          awk "/primary/{nr[NR]; nr[NR+1]}; NR in nr")"
            if echo "${xrandr_out}" | \
                grep -E 'primary [0-9]+x[0-9]+' >/dev/null 2>&1; then
                size="$(echo "${xrandr_out}" | head -n1 | cut -d' ' -f4 | \
                        cut -d'+' -f1)"
            else
                size="$(echo "${xrandr_out}" | tail -n1 | awk '{ print $1 }')"
            fi

            "${XRANDR}" --output "$(list_get 1 "${plug_mons}")" \
                --auto --scale-from  "${size}" \
                --output "$(list_head "${plug_mons}")"
            exit $?
        fi

        if $eFlag ; then
            "${XRANDR}" --output "$(list_get 1 "${plug_mons}")" \
                "$(arg2xrandr "$eArg")" "$(list_head "${plug_mons}")"
            exit $?
        fi
    else
        echo 'At most two plugged monitors for this option.'
    fi
}

main "$@"
